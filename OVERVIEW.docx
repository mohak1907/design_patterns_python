Overview of Design Pattern Categories
Design patterns are categorized into three main types based on their purpose: Creational, Structural, and Behavioral Patterns. Each category serves a different role in software development.

1. Creational Design Patterns
💡 Purpose: These patterns focus on the creation of objects in a flexible, efficient, and reusable way. They help abstract the instantiation process and manage object creation without exposing the instantiation logic.
Most Commonly Used Creational Patterns in Real-World Applications
    1. Singleton 🚀
        ◦ Ensures that a class has only one instance and provides a global access point. 
        ◦ 📌 Used in: Logging systems, configuration managers, database connections, thread pools. 
    2. Factory Method 🏭
        ◦ Defines an interface for creating objects but lets subclasses decide which class to instantiate. 
        ◦ 📌 Used in: Dependency injection, UI component creation, database connectors. 
    3. Abstract Factory 🏭🏭
        ◦ Provides an interface for creating families of related objects without specifying concrete classes. 
        ◦ 📌 Used in: GUI toolkits (cross-platform UI components), database drivers, theme-based application settings. 
    4. Builder 🏗
        ◦ Separates object construction from representation, allowing step-by-step object creation. 
        ◦ 📌 Used in: Complex object construction (e.g., JSON/XML parsers, report generators, SQL query builders). 
    5. Prototype 🧬
        ◦ Creates objects by cloning an existing object rather than instantiating new ones. 
        ◦ 📌 Used in: Object caching, game development (cloning sprites, NPCs), document management systems. 


2. Structural Design Patterns
🧩 Purpose: These patterns organize and optimize relationships between classes and objects to improve code readability, flexibility, and maintainability.
Most Commonly Used Structural Patterns in Real-World Applications
    1. Adapter 🔌
        ◦ Converts an incompatible interface into one that clients expect. 
        ◦ 📌 Used in: Third-party API integration, legacy system compatibility, payment gateways. 
    2. Decorator 🎭
        ◦ Adds new behavior to an object dynamically without modifying its structure. 
        ◦ 📌 Used in: UI elements (adding scrollbars, borders), logging wrappers, data compression. 
    3. Proxy 🛡
        ◦ Controls access to an object, providing a substitute or placeholder for another object. 
        ◦ 📌 Used in: Security proxies (firewalls), virtual proxies (lazy-loading large objects), caching proxies. 
    4. Facade 🏛
        ◦ Provides a simplified interface to a complex subsystem, hiding unnecessary details. 
        ◦ 📌 Used in: API design, media conversion libraries, ORM frameworks (like SQLAlchemy). 
    5. Bridge 🌉
        ◦ Decouples abstraction from implementation, allowing both to vary independently. 
        ◦ 📌 Used in: GUI frameworks (separating rendering logic from UI logic), device drivers. 
    6. Flyweight 🦋
        ◦ Reduces memory usage by sharing common data among multiple objects. 
        ◦ 📌 Used in: Text editors (character formatting), database connection pools, game development (reusing sprites). 
    7. Composite 🌲
        ◦ Treats individual objects and compositions of objects uniformly (tree structures). 
        ◦ 📌 Used in: UI component trees (menus, folders), file systems, hierarchical structures. 


3. Behavioral Design Patterns
🧠 Purpose: These patterns focus on object interaction and communication, ensuring efficient data flow between objects.
Most Commonly Used Behavioral Patterns in Real-World Applications
    1. Observer 👀
        ◦ Allows one object to notify multiple observers when its state changes. 
        ◦ 📌 Used in: Event listeners (GUI, webhooks), stock market tracking, pub-sub systems. 
    2. Strategy 🏃‍♂️
        ◦ Defines a family of algorithms, encapsulates them, and allows them to be interchanged at runtime. 
        ◦ 📌 Used in: Payment processing (Credit Card, PayPal, Bitcoin), sorting algorithms, AI behaviors. 
    3. Command 🎮
        ◦ Encapsulates a request as an object, allowing request execution, queuing, and undoing. 
        ◦ 📌 Used in: GUI buttons, undo/redo functionality, task scheduling. 
    4. State 🚦
        ◦ Allows an object to change its behavior when its internal state changes, avoiding conditionals. 
        ◦ 📌 Used in: Traffic light systems, media players (Play/Pause/Stop), authentication systems. 
    5. Chain of Responsibility 🔗
        ◦ Passes requests along a chain of handlers until one can handle it. 
        ◦ 📌 Used in: Middleware (logging, authentication, request processing), approval workflows. 
    6. Mediator 🗣
        ◦ Defines a central mediator object to manage complex communication between objects. 
        ◦ 📌 Used in: Chat applications, UI component interactions, messaging systems. 
    7. Template Method 📑
        ◦ Defines a skeleton of an algorithm in a base class while allowing subclasses to implement certain steps. 
        ◦ 📌 Used in: Game AI behavior, report generation, data parsers. 
    8. Memento 🏷
        ◦ Saves and restores an object’s previous state without exposing its internal details. 
        ◦ 📌 Used in: Undo/redo functionality, checkpoints in video games. 
    9. Visitor 🚶
        ◦ Adds new operations to existing object structures without modifying their classes. 
        ◦ 📌 Used in: AST (Abstract Syntax Trees), file system analysis. 
    10. Interpreter 📜
    • Defines a grammar for a language and interprets sentences in that language. 
    • 📌 Used in: Scripting languages, SQL query processing, compilers. 


Summary Table
Category
Purpose
Most Used Patterns
Creational
Manages object creation efficiently.
Singleton, Factory Method, Builder
Structural
Optimizes class and object relationships.
Adapter, Decorator, Facade, Proxy
Behavioral
Enhances object communication & flexibility.
Observer, Strategy, Command, State

Which Design Patterns Are Most Used in Real-World Applications?
    1. Singleton - Database connections, configuration settings. 
    2. Factory Method - Dependency injection, service creation. 
    3. Observer - Event-driven programming, GUI applications. 
    4. Strategy - Algorithm selection, AI behavior. 
    5. Decorator - UI enhancements, logging. 
    6. Proxy - API security, caching. 
    7. Facade - Simplified API access. 
    8. Command - Undo/redo functionality, remote controls. 
    9. State - Media players, authentication systems. 
    10. Builder - Complex object creation, report generators.

